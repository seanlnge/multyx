"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultyxClients = exports.MultyxTeam = exports.MultyxValue = exports.MultyxObject = void 0;
const utils_1 = require("./utils");
class MultyxObject {
    constructor(object, client, propertyPath = []) {
        this.data = {};
        this.propertyPath = propertyPath;
        this.client = client;
        for (const prop in object) {
            this.data[prop] = new (typeof object[prop] == 'object' ? MultyxObject : MultyxValue)(object[prop], client, [...propertyPath, prop]);
        }
    }
    disable() {
        for (const prop in this.data) {
            this.data[prop].disable();
        }
        return this;
    }
    enable() {
        for (const prop in this.data) {
            this.data[prop].enable();
        }
        return this;
    }
    public(team = exports.MultyxClients) {
        for (const prop in this.data) {
            this.data[prop].public(team);
        }
        return this;
    }
    /**
     * Check if property is in object
     */
    has(property) {
        return property in this.data;
    }
    /**
     * Get the ClientValue object of a property
     */
    get(property) {
        return this.data[property];
    }
    /**
     * Set the explicit value of the ClientValue object of a property
     * @example
     * ```js
     * // Server
     * multyx.on('reset', client => client.player.setValue('x', 5));
     *
     * // Client
     * client.player.x = 20 * Math.random();
     * multyx.send('reset');
     * console.log(client.player.x); // 5
     * ```
     */
    set(property, value) {
        // If just a normal value change, no need to update shape, can return
        if (typeof value !== "object" && this.data[property] instanceof MultyxValue) {
            return this.data[property].set(value);
        }
        const propertyPath = [...this.propertyPath, property];
        if (typeof value !== "object") {
            this.data[property] = new MultyxValue(value, this.client, propertyPath);
        }
        else if (!(value instanceof MultyxObject)) {
            this.data[property] = new MultyxObject(value, this.client, propertyPath);
        }
        else {
            this.data[property] = value;
            value.editPropertyPath(propertyPath);
        }
        this.client.server.editUpdate(this, (new Set()).add(this.client));
        return this;
    }
    get raw() {
        const parsed = {};
        for (const prop in this.data) {
            const m = this.data[prop];
            if (m instanceof MultyxValue) {
                parsed[prop] = m.value;
            }
            else {
                parsed[prop] = m.raw;
            }
        }
        return parsed;
    }
    getPublic(team = exports.MultyxClients) {
        const parsed = {};
        for (const prop in this.data) {
            const m = this.data[prop];
            if (m instanceof MultyxValue) {
                if (m.isPublic(team))
                    parsed[prop] = m.value;
            }
            else {
                parsed[prop] = m.raw;
            }
        }
        return parsed;
    }
    buildConstraintTable() {
        const table = {};
        for (const prop in this.data) {
            table[prop] = this.data[prop].buildConstraintTable();
        }
        return table;
    }
    editPropertyPath(newPath) {
        this.propertyPath = newPath;
        for (const prop in this.data) {
            if (this.data[prop] instanceof MultyxObject) {
                this.editPropertyPath([...this.propertyPath, prop]);
            }
            else {
                this.data[prop].propertyPath = [...this.propertyPath, prop];
            }
        }
    }
}
exports.MultyxObject = MultyxObject;
class MultyxValue {
    constructor(value, client, propertyPath) {
        this.min = (value) => {
            this.constraints.set('min', {
                args: [value],
                func: n => n >= value ? n : value
            });
            return this;
        };
        this.max = (value) => {
            this.constraints.set('max', {
                args: [value],
                func: n => n <= value ? n : value
            });
            return this;
        };
        this.ban = (value) => {
            this.bannedValues.add(value);
            return this;
        };
        this.constrain = (func) => {
            this.manualConstraints.push(func);
            return this;
        };
        this.value = value;
        this.disabled = false;
        this.constraints = new Map();
        this.manualConstraints = [];
        this.bannedValues = new Set();
        this.publicTeams = new Set();
        this.propertyPath = propertyPath;
        this.client = client;
    }
    disable() {
        this.disabled = true;
        return this;
    }
    enable() {
        this.disabled = false;
        return this;
    }
    public(team = exports.MultyxClients) {
        this.publicTeams.add(team);
        team.publicData.add(this);
    }
    isPublic(team = exports.MultyxClients) {
        return this.publicTeams.has(team);
    }
    set(value) {
        // If client attempting to edit value
        const isEditWrapper = value instanceof utils_1.EditWrapper;
        if (value instanceof utils_1.EditWrapper) {
            if (this.disabled)
                return false;
            value = value.data;
        }
        // Check if value setting changes constraints
        const oldValue = value;
        for (const [_, { func }] of this.constraints.entries()) {
            const constrained = func(value);
            if (constrained === null)
                return false;
            value = constrained;
        }
        for (const constraint of this.manualConstraints) {
            const constrained = constraint(value);
            if (constrained === null)
                return false;
            value = constrained;
        }
        if (this.bannedValues.has(value))
            return false;
        this.value = value;
        // Create client list
        const clients = new Set([this.client]);
        for (const team of this.publicTeams) {
            for (const client of team.clients) {
                clients.add(client);
            }
        }
        if (oldValue === this.value && isEditWrapper)
            clients.delete(this.client);
        // Tell client to relay update
        this.client.server.editUpdate(this, clients);
        return { clients };
    }
    buildConstraintTable() {
        const obj = {};
        for (const [cname, { args }] of this.constraints.entries()) {
            obj[cname] = args;
        }
        return obj;
    }
}
exports.MultyxValue = MultyxValue;
class MultyxTeam {
    constructor(clients) {
        this.publicData = new Set();
        if (!clients) {
            this.clients = new Set();
            return;
        }
        this.clients = new Set();
        clients.forEach(c => {
            c.teams.add(this);
            this.clients.add(c);
        });
    }
    addClient(client) {
        this.clients.add(client);
        client.teams.add(this);
    }
    getPublic() {
        const parsed = new Map();
        this.clients.forEach(c => parsed.set(c, c.shared.getPublic(this)));
        return parsed;
    }
}
exports.MultyxTeam = MultyxTeam;
exports.MultyxClients = new MultyxTeam();
